# 杂记（等数量多了以后，再分类）
- 1.睡眠排序  
　　在介绍睡眠排序之前，先介绍另一种排序，意大利面排序。将长短不一样的意大利面，一端对齐，用手握住，然后开始往低处降落。最先触到桌子的面条就是最长的。最后触到桌子的就是最短的。原理很简单，但是这种排序用程序实现好像没什么思路。睡眠排序的原理和意大利面排序原理类似，且可以实现。用系统的软件定时器实现。在同一时刻，开始定时，定时时间就是排序的时间。时间到了以后，打印自己的定时时间。在时间到达之前，每个进程都像是在睡眠。比如要排序的数是1-5。那么根据这个原理，一定是1最先打印，5最后打印。用这种方式既可实现排序。  
　　注意点：如果排序的数很小，比如是0.001-0.005，可以将所有的数放大一定的倍数，比如1000倍。或者排序的数很大，1001-1005，可以将所有的数减去1000再排序，避免了排一次序要等1000多秒。不过如果排序的数差异很大，例如1和1000比较。那这种方式就不适合了。  
　　这种排序法，主要是开阔一下思维。实际应用中，个人觉得实用性可能不是太大。
- 1.单片机在调用函数时的堆栈分析
  以前一直没有研究过函数调用的时候的具体过程。最开始写单片机程序的时候，都是一个main到底。后来开始有了模块化的概念，会将一些功能写成一个或多个函数。然后在main里调用这些函数。那么程序在调用这些函数的时候，具体的情况是怎么样的。下面通过一个实例来说明。
